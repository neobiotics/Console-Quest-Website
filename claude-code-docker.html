<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Running Claude Code in Docker: Because SSH is All You Need - Console Quest</title><meta name="description" content="How to run Claude Code CLI in a Docker container with SSH access, API key authentication, and persistent Git integration. No OAuth, no browser needed."><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://consolequest.net/claude-code-docker.html"><link rel="alternate" type="application/atom+xml" href="https://consolequest.net/feed.xml" title="Console Quest - RSS"><link rel="alternate" type="application/json" href="https://consolequest.net/feed.json" title="Console Quest - JSON"><meta property="og:title" content="Running Claude Code in Docker: Because SSH is All You Need"><meta property="og:image" content="https://consolequest.net/media/posts/8/Gemini_Generated_Image_fqvcf6fqvcf6fqvc-1.png"><meta property="og:image:width" content="4096"><meta property="og:image:height" content="4096"><meta property="og:site_name" content="Console Quest"><meta property="og:description" content="How to run Claude Code CLI in a Docker container with SSH access, API key authentication, and persistent Git integration. No OAuth, no browser needed."><meta property="og:url" content="https://consolequest.net/claude-code-docker.html"><meta property="og:type" content="article"><link rel="preload" href="https://consolequest.net/assets/dynamic/fonts/publicsans/publicsans.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://consolequest.net/assets/css/style.css?v=f3255e888ee4af56f3e8437a2c4c99f3"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://consolequest.net/claude-code-docker.html"},"headline":"Running Claude Code in Docker: Because SSH is All You Need","datePublished":"2026-01-11T14:38+01:00","dateModified":"2026-01-20T23:35+01:00","image":{"@type":"ImageObject","url":"https://consolequest.net/media/posts/8/Gemini_Generated_Image_fqvcf6fqvcf6fqvc-1.png","height":4096,"width":4096},"description":"How to run Claude Code CLI in a Docker container with SSH access, API key authentication, and persistent Git integration. No OAuth, no browser needed.","author":{"@type":"Person","name":"Juri Steiner","url":"https://consolequest.net/authors/juri-steiner/"},"publisher":{"@type":"Organization","name":"Juri Steiner"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><div class="container"><div class="left-bar"><div class="left-bar__inner"><header class="header"><a class="logo" href="https://consolequest.net/">Console Quest </a><a class="logo logo--atbottom" href="https://consolequest.net/">Console Quest</a></header></div></div><main class="main post"><article class="content"><figure class="content__featured-image content__featured-image--attop"><img src="https://consolequest.net/media/posts/8/Gemini_Generated_Image_fqvcf6fqvcf6fqvc-1.png" srcset="https://consolequest.net/media/posts/8/responsive/Gemini_Generated_Image_fqvcf6fqvcf6fqvc-1-xs.png 320w, https://consolequest.net/media/posts/8/responsive/Gemini_Generated_Image_fqvcf6fqvcf6fqvc-1-sm.png 480w, https://consolequest.net/media/posts/8/responsive/Gemini_Generated_Image_fqvcf6fqvcf6fqvc-1-md.png 768w, https://consolequest.net/media/posts/8/responsive/Gemini_Generated_Image_fqvcf6fqvcf6fqvc-1-xl.png 1024w" sizes="(min-width: 1460px) 938px, (min-width: 1200px) calc(75.83vw - 154px), (min-width: 1120px) 938px, (min-width: 900px) calc(55vw + 333px), 100vw" loading="eager" height="4096" width="4096" alt="Retro pixel art diagram showing Console Quest architecture: multiple computers connecting via SSH to a central Docker container displaying &#x27;SSH ACCESS GRANTED&#x27;, which connects to Claude Code API in the cloud" aria-describedby="image-caption"></figure><div class="content__meta content__meta--attop"><div class="content__meta--attop__inner"><div class="content__maintag"><svg width="20" height="20" aria-hidden="true" focusable="false"><use xlink:href="https://consolequest.net/assets/svg/svg-map.svg#tag"/></svg> Published in <a href="https://consolequest.net/tags/docker/" class="metadata__maintag">docker</a></div><div id="image-caption" class="content__featured-image__caption"><svg width="20" height="20" aria-hidden="true" focusable="false"><use xlink:href="https://consolequest.net/assets/svg/svg-map.svg#image"/></svg> Because even a technical blog post about Docker containers and OAuth bypasses deserves a dramatic retro diagram, here&#x27;s some AI slop in finest pixel aesthetics. SSH access has never looked this pixelated. Generated by Gemini 3 Flash / Nano Banana</div></div></div><div class="main__inner"><div class="content__meta"><div class="content__author"><div><a href="https://consolequest.net/authors/juri-steiner/" class="content__author__name">Juri Steiner</a></div></div><div class="content__date"><time datetime="2026-01-11T14:38">Jan 11, 2026</time></div></div><header class="content__header"><h1 class="content__title">Running Claude Code in Docker: Because SSH is All You Need</h1></header><div class="content__entry"><p>Claude Code is excellent. It’s fast, it understands context, and it actually helps you write better code. It even supports remote authentication - you can grab an OAuth token via browser on any device and paste it in. There’s just one tiny problem: I’m weird and want to run it in a Docker container.</p><p>Containers don’t persist login state. Every restart, every rebuild - gone. Back to square one.</p><h2 id="why-run-claude-code-in-a-container">Why Run Claude Code in a Container?</h2><p>Fair question. Why not just run it locally like a normal person?</p><p>Because I work from way too many machines. Sometimes my desktop, sometimes my laptop - shit, maybe even from my work computer during breaks. I wanted one consistent environment I could SSH into from anywhere, with my notes and context already there.</p><p>Also, I’ll be honest: an AI with full access to my machine creeps me out a little. Inside a Docker container? Much better. It can do its thing in there, isolated, and I sleep easier.</p><p>And okay, fine - I also just wanted to see if it was possible.</p><h2 id="the-oauth-problem">The OAuth Problem</h2><p>When you start Claude Code, it asks: Claude subscription or API key?</p><p>Sounds like a choice. It’s not really. Both paths lead to OAuth - just to different endpoints:</p><ul><li><strong>Claude subscription</strong> → OAuth via claude.ai</li><li><strong>API key</strong> → OAuth via console.anthropic.com</li></ul><p>Either way: browser, login, authentication state that doesn’t survive a container restart.</p><p>But here’s the thing - you can set <code>ANTHROPIC_API_KEY</code> as an environment variable, and Claude Code will use it directly. No OAuth. This is actually documented for SDK usage. The catch? It still shows a confirmation dialog asking if you trust this key. In a container that rebuilds, you’d have to confirm every single time.</p><p>Unless you know where it stores that trust. That part isn’t in the docs.</p><h2 id="the-trust-config-discovery">The Trust Config Discovery</h2><p>After some digging (and reading way too much source code), I found that Claude Code stores trusted keys in <code>~/.claude.json</code>. The interesting part? It doesn’t store the full API key - just the last 20 characters for verification.</p><p>This means we can pre-populate the trust config:</p><pre><code class="language-json">{
  &quot;customApiKeyResponses&quot;: {
    &quot;approved&quot;: [&quot;...last20chars...&quot;],
    &quot;rejected&quot;: []
  },
  &quot;hasCompletedOnboarding&quot;: true,
  &quot;hasTrustDialogAccepted&quot;: true
}
</code></pre><p>Those flags skip the onboarding flow entirely. No browser needed, no interactive prompts, just straight to work.</p><h2 id="building-the-container">Building the Container</h2><p>The Dockerfile is straightforward - Ubuntu base, SSH server, Claude Code CLI:</p><pre><code class="language-dockerfile">FROM ubuntu:24.04

# System packages
RUN apt-get update &amp;&amp; apt-get install -y \
    openssh-server \
    ssh-import-id \
    curl git vim htop ripgrep jq \
    nodejs npm \
    &amp;&amp; rm -rf /var/lists/*

# SSH setup - key-based auth only
RUN mkdir /var/run/sshd \
    &amp;&amp; mkdir -p /root/.ssh \
    &amp;&amp; chmod 700 /root/.ssh \
    &amp;&amp; echo &quot;PermitRootLogin yes&quot; &gt;&gt; /etc/ssh/sshd_config \
    &amp;&amp; echo &quot;PasswordAuthentication no&quot; &gt;&gt; /etc/ssh/sshd_config \
    &amp;&amp; echo &quot;PubkeyAuthentication yes&quot; &gt;&gt; /etc/ssh/sshd_config

# Claude Code CLI
RUN npm install -g @anthropic-ai/claude-code

# Workspace
RUN mkdir -p /workspace/notes

EXPOSE 22
ENTRYPOINT [&quot;/entrypoint.sh&quot;]
</code></pre><p>The entrypoint script is where the magic happens - it sets up SSH keys, configures the API key trust, and starts the SSH server:</p><pre><code class="language-bash">#!/bin/bash
set -e

# Import SSH keys from GitHub
if [ -n &quot;$GITHUB_USERS&quot; ]; then
    ssh-import-id-gh ${GITHUB_USERS//,/ }
fi

# Claude Code API Key Setup
if [ -n &quot;$ANTHROPIC_API_KEY&quot; ]; then
    # Make key available in SSH sessions
    echo &quot;export ANTHROPIC_API_KEY=\&quot;$ANTHROPIC_API_KEY\&quot;&quot; &gt;&gt; /root/.bashrc
    
    # Extract last 20 characters for trust config
    ANTHROPIC_API_KEY_LAST_20=&quot;${ANTHROPIC_API_KEY: -20}&quot;
    
    # Create trust config
    cat &lt;&lt;EOF &gt; /root/.claude.json
{
  &quot;customApiKeyResponses&quot;: {
    &quot;approved&quot;: [&quot;$ANTHROPIC_API_KEY_LAST_20&quot;],
    &quot;rejected&quot;: []
  },
  &quot;hasCompletedOnboarding&quot;: true,
  &quot;hasTrustDialogAccepted&quot;: true
}
EOF
fi

# Start SSH server
exec /usr/sbin/sshd -D
</code></pre><p>The <code>ssh-import-id-gh</code> command is criminally underrated - it pulls your public SSH keys directly from GitHub. No manual key management needed.</p><h2 id="then-i-wanted-to-push-to-github">Then I Wanted to Push to GitHub</h2><p>The container worked. Claude Code ran headless. I could SSH in and use it. Perfect.</p><p>Then I made some changes, felt productive, typed <code>git push</code> and… right. SSH keys. In a container. That I didn’t mount.</p><p>Sound familiar? Non-persistent authentication, round two. Apparently I needed to learn this lesson twice.</p><p>The problem is persistence:</p><pre><code class="language-yaml">volumes:
  - ./notes:/workspace/notes       # ✅ Persistent
  - ./claude-data:/root/.claude    # ✅ Persistent
  # But /root/.ssh?                # ❌ NOT mounted = gone on restart
</code></pre><p>SSH keys stored in <code>/root/.ssh</code> disappear on container restart. I could mount that directory too, but there’s a simpler solution: Git credential helper with a persistent location.</p><pre><code class="language-bash">git config --global credential.helper &#39;store --file=/root/.claude/.git-credentials&#39;
</code></pre><p>Since <code>/root/.claude</code> is already bind-mounted, the credentials file survives container restarts. On first push, Git asks for credentials - I enter my GitHub Personal Access Token - and it’s stored. Every subsequent push works automatically.</p><p>This actually feels cleaner than SSH keys for containers. The token is revocable from GitHub’s settings, it doesn’t require key generation, and it works identically across any machine. Sometimes the workaround becomes the better solution.</p><h2 id="the-final-setup">The Final Setup</h2><p>Here’s the complete docker-compose configuration:</p><pre><code class="language-yaml">services:
  claude-code:
    build: ./claude-ssh
    container_name: claude-code
    ports:
      - &quot;2222:22&quot;
    volumes:
      - ./notes:/workspace/notes
      - ./claude-data:/root/.claude
    environment:
      - GITHUB_USERS=${GITHUB_USERS}
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
    restart: unless-stopped
</code></pre><p>With a <code>.env</code> file:</p><pre><code class="language-bash">GITHUB_USERS=your-github-username
ANTHROPIC_API_KEY=sk-ant-xxxxx
</code></pre><p>That’s it. Run <code>docker compose up -d --build</code>, wait about 5 minutes for npm to install Claude Code, then:</p><pre><code class="language-bash">ssh -p 2222 root@your-server
cd /workspace/notes
claude
</code></pre><p>No OAuth flow. No onboarding. No manual SSH key setup. Just Claude Code, ready to use, with working Git integration.</p><h2 id="bonus-pairing-with-a-markdown-editor">Bonus: Pairing with a Markdown Editor</h2><p>I run this alongside <a href="https://github.com/gamosoft/notediscovery">NoteDiscovery</a>, a simple web UI for browsing Markdown files:</p><pre><code class="language-yaml">services:
  notediscovery:
    image: ghcr.io/gamosoft/notediscovery:latest
    ports:
      - &quot;8800:8000&quot;
    volumes:
      - ./notes:/app/data

  claude-code:
    # ... as above
</code></pre><p>Both containers share the same notes directory. I browse and organize in the web UI, edit with Claude Code via SSH. It’s simple, it works, and I can access it from anywhere.</p><h2 id="current-setup">Current Setup</h2><blockquote><p><strong>Container Platform:</strong> Docker Compose on TrueNAS Scale → Dockge for management</p></blockquote><blockquote><p><strong>Claude Code:</strong> Latest version via npm global install → API key auth, OAuth bypassed</p></blockquote><blockquote><p><strong>SSH Access:</strong> Port 2222 exposed → Keys automatically pulled from GitHub</p></blockquote><blockquote><p><strong>Persistence:</strong> Two bind mounts → notes/ and .claude/ directory, credentials survive restarts</p></blockquote><blockquote><p><strong>Git Integration:</strong> Personal Access Token → Stored in persistent location, works across rebuilds</p></blockquote><blockquote><p><strong>Companion Service:</strong> NoteDiscovery web UI → Same notes volume, different access method</p></blockquote><h2 id="whats-next">What’s Next</h2><p>The setup works. But man, this thing churns through tokens like crazy. From jumping into the SSH session to pushing the <a href="https://github.com/neobiotics/claude-markdown-workspace">GitHub repo</a> - okay, and making it barely presentable to the whole internet - five bucks were gone.</p><p>So I’m looking at <a href="https://github.com/anomalyco/opencode">opencode</a> as an alternative. It has multi-provider support, so I could use cheaper models for simple tasks. Native web UI too, which might eliminate the SSH dance entirely. And maybe a Code Server container bolted on sideways at some point. We’ll see.</p><p>The whole setup is <a href="https://github.com/neobiotics/claude-markdown-workspace">published on GitHub</a> if you want the complete config.</p><hr><p><em>What’s your remote development setup look like? Are you running AI coding assistants in containers, or am I the only one who thought SSH-ing into a TUI was a good idea?</em></p></div><footer class="content__footer"><div class="content__last-updated">This article was updated on <time datetime="2026-01-20T23:35">Jan 20, 2026</time></div><div class="content__share"></div></footer></div></article></main><div class="right-bar"><div class="right-bar__inner"><div class="sidebar"><section class="box authors"><h3 class="box__title">Authors</h3><ul class="authors__cotainer"><li class="authors__item"><div><a href="https://consolequest.net/authors/juri-steiner/" class="authors__title">Juri Steiner</a> <span class="authors__meta">Post: 4</span></div></li></ul></section><section class="box tags"><h3 class="box__title">Recommended Topics</h3><ul class="tags__list"><li class="tags__item"><a href="https://consolequest.net/tags/docker/" class="btn btn--gray">docker <sup>(2)</sup></a></li><li class="tags__item"><a href="https://consolequest.net/tags/documentation/" class="btn btn--gray">documentation <sup>(2)</sup></a></li><li class="tags__item"><a href="https://consolequest.net/tags/hardware/" class="btn btn--gray">hardware <sup>(1)</sup></a></li><li class="tags__item"><a href="https://consolequest.net/tags/homelab/" class="btn btn--gray">homelab <sup>(3)</sup></a></li><li class="tags__item"><a href="https://consolequest.net/tags/introduction/" class="btn btn--gray">introduction <sup>(1)</sup></a></li><li class="tags__item"><a href="https://consolequest.net/tags/mistake/" class="btn btn--gray">mistake <sup>(1)</sup></a></li><li class="tags__item"><a href="https://consolequest.net/tags/planning/" class="btn btn--gray">planning <sup>(1)</sup></a></li><li class="tags__item"><a href="https://consolequest.net/tags/projects/" class="btn btn--gray">projects <sup>(1)</sup></a></li><li class="tags__item"><a href="https://consolequest.net/tags/selfhosting/" class="btn btn--gray">selfhosting <sup>(2)</sup></a></li><li class="tags__item"><a href="https://consolequest.net/tags/truenas/" class="btn btn--gray">truenas <sup>(1)</sup></a></li></ul></section><div class="box copyright">Powered by Publii - Open-Source CMS for Static Websites</div></div></div></div></div><script defer="defer" src="https://consolequest.net/assets/js/scripts.min.js?v=b2d91bcadbf5db401b76eb5bb3092eb7"></script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>